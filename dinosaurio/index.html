<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Dinosaur Canvas Game</title>
    <style>
        body { margin: 0; background: #e0f7fa; }
        canvas { display: block; margin: 0 auto; background: #a7ffeb; }
    </style>
</head>
<body>
<canvas id="gameCanvas" width="800" height="500"></canvas>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Dinosaur image URLs (OpenMoji PNGs)
const dinoImages = [
    "images/sauropod.png", // Sauropod
    "images/trex.png"  // T-Rex
];

class Dinosaur {
    constructor(x, y, imgUrl) {
        this.x = x;
        this.y = y;
        this.size = 100;
        this.img = new Image();
        this.img.src = imgUrl;
        this.selected = false;
    }

    draw(ctx) {
        // Selection outline
        if (this.selected) {
            ctx.save();
            ctx.strokeStyle = "#ffeb3b";
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.arc(this.x + this.size/2, this.y + this.size/2, this.size/2 + 8, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
        }
        ctx.drawImage(this.img, this.x, this.y, this.size, this.size);
    }

    isPointInside(px, py) {
        // Simple bounding box hit test
        return px >= this.x && px <= this.x + this.size &&
               py >= this.y && py <= this.y + this.size;
    }
}

const dinosaurs = [
    new Dinosaur(200, 300, dinoImages[0]),
    new Dinosaur(500, 200, dinoImages[1])
];

let selectedDino = null;
let offsetX = 0, offsetY = 0;
let dragging = false;

function drawHexagon(x, y, size, fillStyle, strokeStyle) {
    ctx.save();
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
        const angle = Math.PI / 3 * i + Math.PI / 6; // flat-topped orientation
        const px = x + size * Math.cos(angle);
        const py = y + size * Math.sin(angle);
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
    }
    ctx.closePath();
    ctx.fillStyle = fillStyle;
    ctx.fill();
    ctx.strokeStyle = strokeStyle;
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.restore();
}


function drawHexGrid(size) {
    const horizSpacing = size * Math.sqrt(3); // width between centers
    const vertSpacing = size * 1.5;           // height between rows

    const cols = Math.ceil(canvas.width / horizSpacing) + 1;
    const rows = Math.ceil(canvas.height / vertSpacing) + 1;

    for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
            const x = col * horizSpacing + (row % 2) * (horizSpacing / 2);
            const y = row * vertSpacing;
            drawHexagon(x, y, size, "#b9f6ca", "#388e3c");
        }
    }
}




function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const hexSize = 45;
    drawHexGrid(hexSize);

    // Draw dinosaurs
    for (const dino of dinosaurs) {
        ctx.save();
        dino.draw(ctx);
        ctx.restore();
    }
}

// Wait for both images to load before first draw
let imagesLoaded = 0;
dinosaurs.forEach(d => {
    d.img.onload = () => {
        imagesLoaded++;
        if (imagesLoaded === dinosaurs.length) {
            draw();
        }
    };
});

canvas.addEventListener('mousedown', (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    let found = false;
    for (const dino of dinosaurs) {
        if (dino.isPointInside(mx, my)) {
            dinosaurs.forEach(d => d.selected = false);
            dino.selected = true;
            selectedDino = dino;
            offsetX = mx - dino.x;
            offsetY = my - dino.y;
            dragging = true;
            found = true;
            break;
        }
    }
    if (!found) {
        dinosaurs.forEach(d => d.selected = false);
        selectedDino = null;
    }
    draw();
});

canvas.addEventListener('mousemove', (e) => {
    if (dragging && selectedDino) {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        selectedDino.x = mx - offsetX;
        selectedDino.y = my - offsetY;
        draw();
    }
});

canvas.addEventListener('mouseup', () => {
    dragging = false;
});
</script>
</body>
</html>